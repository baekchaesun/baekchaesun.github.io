---
layout: post
date: 2023-03-21 18:29:51 +0900
title: "selectsort"
---

# selectsort (선택정렬)  
### : 배열을 순회하며 가장 작은 값을 선택해서 앞으로 보냄으로써 배열을 정렬하는 알고리즘.

mergesort 와 다르게 또 다른 배열을 만들지 않고 정렬하는 방법이 있어서 해봤다.

mergesort의 시간복잡도 : O(n log n)  
selectsort의 시간복잡도 : O(n^2)  
-> 시간 복잡도가 커서 데이터 크기가 커질수록 성능이 저하된다.

```
public static void seletSort (int [] a) {

	int n = a.length;
	int i = 0;
	int min = i;
```
1. 일단 배열 `a`의 길이를 `n`변수로 설정했다.   
-> 배열 길이만큼 반복해야하기 때문에 필요하다.
2. 변수 `i`는 배열 `a`을 순회할 때 이용할 예정  
3. 변수 `min`은 배열 앞에 대입할 최소 숫자.


### while 반복문으로 배열을 순회하며 최소 숫자를 찾자.
```
	while (i < n - 1) {
		min = i;
		int j = i + 1;
		
		while (j < n) {
			if (a[j] < a[min])
				min = j;
			j++;
		}
		
		int b = a[i];
		a[i] = a[min];
		a[min] = b;

		i++;
	}
```
`while (i < n - 1)` : 인덱스는 0부터 시작이므로 마지막 인덱스는 (n - 1)이다.
1. 최소 숫자 `min`변수에 배열 인덱스 `i` 대입.  
-> `a[i]`가 가장 작으면 `a[min]`에 넣고 옮길 것이기 때문이다.  
2. `j` 변수는 `i`가 순회할때 비교할 대상이다. (`a[i]`의 다음 값인 `a[i + 1]`과 비교한다.)  
3. `while (j < n)` : `j = i + 1` 이기때문에 n번 반복해줘야 위 while반복문과 순서 맟출 수 있다.
	1. `if (a[j] < a[min])` 앞에 숫자 `min`이 더 크면 실행
	2. `min = j` 
	3. `j++;` : j 1 추가 (배열 인덱스 한칸 옆으로 가기)
4. 최소 숫자 `min`을 현재 위치 `i`와 바꾼다.
	1. 임시 변수 `b`에다가 `a[i]`값을 저장
	2. 최소숫자 `a[min]`을 현재위치 `a[i]`에 저장
	3. 임시 변수 `b`에 저장돼있던 값을 원래 최소 숫자가 있던 위치 `a[min]`에 저장
5. `i++;` : 현재 위치 한칸 이동. 그리고 위 while문 다시 반복. (`n`번 반복)


---


#### 끝.